<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swiper如何实现内容超出滑动]]></title>
    <url>%2F2017%2F09%2F07%2Fswiper_flow%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;对于使用Swiper实现整屏滑动的页面，如果某一页内容超过一屏高度，超出部分将无法通过滚动条下滑查看，即便我们设置了overflow:scroll。 &emsp;&emsp;如果我们单纯的通过手势判断滑倒上一页/下一页，在一些浏览器表现不佳，所以我们得滑动到有滚动条的部分时，再去触发我们的相关事件。 &emsp;&emsp;最后一页的iPhone专区，其页面内容超过一屏高度，即使我们使出吃奶的劲去滑，超出部分将无法查看到，如图所示：其Css如下：12345.p-other&#123; position: relative; height: 100%; overflow-y: scroll;&#125; &emsp;&emsp;这是为什么呢，因为Swiper注册了touchstart,touchmove,和touchend事件，当手指在屏幕上滑动时,使用CSS3的transform来实时设置viewport的位置，比如要显示第二个页面，就设置viewport的transform:translate3d(100%,0,0)即可， 在这里使用translate3d来代替translateX，translate3d可以主动开启手机GPU加速渲染，页面滑动更流畅。&emsp;&emsp;所以当我们滑到最后一页时，Swiper监听到了touchstart,touchmove等，在改变其translate3d值，所以无法正常查看到超出该屏幕的内容。如下图所示，通过Chrome观察，我们可以看到每一次滑屏，都是translate3d值的改变。 &emsp;&emsp;我们想要的效果是，超出的内容不受影响，出现滚动条，正常上下话查看内容；并且滑到底部/顶部时，仍然可以切换下一屏/上一屏。&emsp;&emsp;在这种情况，我们祭出一段利器，在js中添加如下代码：1234567891011121314151617181920var startScroll, touchStart, touchCurrent;page_swiper.slides.on('touchstart', function (e) &#123; startScroll = this.scrollTop; touchStart = e.targetTouches[0].pageY;&#125;, true);page_swiper.slides.on('touchmove', function (e) &#123; touchCurrent = e.targetTouches[0].pageY; var touchesDiff = touchCurrent - touchStart; //判断滑动方向 var slide = this; var onlyScrolling = ( slide.scrollHeight &gt; slide.offsetHeight ) &amp;&amp; //如果滑动到存在滚动条的结构时，此判断为true ( ( touchesDiff &lt; 0 &amp;&amp; startScroll === 0 ) || //从顶部滚动到底部 ( touchesDiff &gt; 0 &amp;&amp; startScroll === ( slide.scrollHeight - slide.offsetHeight ) ) || //从底部滚动到顶部 ( startScroll &gt; 0 &amp;&amp; startScroll &lt; ( slide.scrollHeight - slide.offsetHeight ) ) //从中间开始 ); if (onlyScrolling) &#123; e.stopPropagation(); //终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播。 &#125;&#125;, true); &emsp;&emsp;其中核心是判断onlyScrolling的状态，当滑动到有滚动条的部分时，slide.scrollHeight &gt; slide.offsetHeight为true，否则为false；当滑到需要Swiper切换的临界点时，如下图所示代码为false,在滚动中间区域时，为true；&emsp;&emsp;所以当onlyScrolling 为true时，可以知道用户在浏览超出滚动的内容，当达到临界点想离开时，onlyScrolling为false，不再阻止Swiper滑动，整屏可自由滑动。&emsp;&emsp;当onlyScrolling为true时，阻止Swiper改变transform值，使超出滚动部分的内容可以正常浏览。如下图所示：&emsp;&emsp;至此，我们大功告成！]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪吃蛇Canvas小游戏]]></title>
    <url>%2F2017%2F08%2F01%2Fcanvas_snake618%2F</url>
    <content type="text"><![CDATA[以儿时热门游戏贪吃蛇作为互动游戏。用户在游戏中可以赢取随机出现的红包（红包概率出现，且一场仅出现一次），并记录用户分数。使用Canvas实现 以下是我制作整个游戏时，遇到的一些问题与解决方法。 活动需求以儿时热门游戏贪吃蛇作为互动游戏。用户在游戏中可以赢取随机出现的红包（红包概率出现，且一场仅出现一次），并记录用户分数。效果如下所示。 游戏实现贪吃蛇绘制思路计算贪吃蛇方向在游戏开始时，贪吃蛇默认朝右移动，当用户点击游戏区域，则记录这个点为目标点，整个贪吃蛇朝着新的目标点运动。否则继续按照之前指定的方向继续运动。效果如左边所示:1234567891011function downFN(e)&#123; switch (gameState) &#123; case 'play': target.x = e.offsetX; target.y = e.offsetY; snake.lastArm.target(target.x, target.y); break; case 'dead': break; &#125;&#125; 当用户按下鼠标时，获取当前按下的位置，改变贪吃蛇前进方向。 根据坐标绘制贪吃蛇根据计算出的各个坐标点，通过 Canvas 的 lineTo() 方法，将这些点连成线段。当线段短到一定程度时，用户便无法通过肉眼分辨出这些是由一段段线段连接而成，从视觉上达到绘制曲线的结果。在每一次更新Canvas时，都会清除之前画布然后再根据当前坐标点重新绘制贪吃蛇，在肉眼看起来“贪吃蛇”就和真的一样，动了起来。那么这些坐标是如何计算出来的呢？ 贪吃蛇坐标计算当我们确定好坐标计算的方法后，便开始每一点坐标的计算。如图所示，贪吃蛇坐标值是由endX()、endY()计算而得。通过当前对象中angle角度值，按照如图所示的公式，可以计算得出该点下一次坐标。 贪吃蛇描边效果设计稿中贪吃蛇具有描边效果，如图所示。先画一条较粗的线段放在下面，然后在画一条较细的线段，放在粗线段的上面，从视觉上达到线段描边效果。设计稿中贪吃蛇具有描边效果，如图所示。因为此贪吃蛇是通过Canvas中的许多小线段拼接而成，并非是一条完整曲线，并且Canvas lineTo() (绘制线段方法)不提供线段描边，虽然可以利用矩形的填充方法可以做到类似于描边效果，但如果使用矩形方法拼接贪吃蛇，需要额外计算与保存坐标点，增加不必要的开销，所以思考如何使用线段实现描边效果。在Canvas中有一个save()和restore()方法，作用是保存当前环境的状态和返回之前保存过的路径状态和属性。所以我们可以利用这个方法，先画一条较粗的线段放在下面，然后在画一条较细的线段，放在粗线段的上面，从视觉上达到线段描边效果。 食物、红包绘制思路食物绘制如图所示贪吃蛇食物共有三种，并且每一个食物的分值都会随着食物出现的时间而锐减。因为食物固定三种，所以将三种食物的位置与颜色储存在数组中，使用 drawImage 绘制食物、fillText绘制食物分值。在每一次更新时，自身生命周期都会减少，当生命周期为0时，该食物被移除。 食物样式: 代码实现： 1234567891011121314151617181920212223function Apple(x, y) &#123; this.x = x; this.y = y; this.life = appleLife; this.rotation = 0; this.index = ~~(Math.random()*100%3);&#125;Apple.prototype.update = function() &#123; this.life--;&#125;;Apple.prototype.render = function(context) &#123; context.drawImage(g_source,appleColor[this.index][0],appleColor[this.index][1],27,27,this.x - appleWidth/2, this.y - appleWidth/2, appleWidth, appleWidth); if (gameState !== 'dead') &#123; context.save(); context.fillStyle = appleColor[this.index][2]; context.font = '11px pingfang'; context.textAlign = 'center'; context.fillText(this.life, this.x, this.y + appleWidth+5); context.restore(); &#125;&#125;; 红包绘制通过代码实现红包动画红包的实现方式与食物相同，这里主要讲一下动画的实现，针对红包动画效果，首先使用Canvas绘制实现，但是调试出满意、不生硬的过度效果（ease-in-out等）需要较长的时间，针对红包效果与设计师沟通之后通过雪碧图实现动画。其原理与CSS3雪碧图动画相同。红包射线动画效果的雪碧图共48帧，约29kb。对于整体资源加载影响不大，这里在动画执行完后在等待30帧时间，作为重复动画中的空白过渡期。 使用代码实现效果(生硬)： 关键代码： 12345678910111213141516171819context.moveTo(-0, -16);context.lineTo(-0, -16-this.len);context.moveTo(0, 16);context.lineTo(0, 16+this.len);context.moveTo( - 16, 0);context.lineTo( - 16-this.len, 0);context.moveTo(16, 0);context.lineTo(16+this.len, 0);context.moveTo( - 16, -16);context.lineTo( - 16-this.len/2, -16-this.len/2);context.moveTo(16, 16);context.lineTo(16+this.len/2, 16+this.len/2);context.moveTo( 16, -16);context.lineTo( 16+this.len/2, -16-this.len/2);context.moveTo(-16, 16);context.lineTo(-16-this.len/2, 16+this.len/2); 使用雪碧图实现(较生动)： 关键代码： 1234567891011121314Bag_w.prototype.render = function(context) &#123; if(this.img)&#123; //控绘制的间隔、循环 this.num ++; if(this.num &gt;=47)&#123; this.n++; if(this.n &gt;=30)&#123; this.num = 0; this.n = 0;; &#125; &#125; context.drawImage(this.img, 116*this.num,0,116,116,this.x-29, this.y-29, 58, 58); &#125;&#125; 其他的思考贪吃蛇进食当贪吃蛇与食物的距离小于一个值时，则 “吃”到了该食物。针对游戏中贪吃蛇碰撞食物、红包等，无需使用复杂的碰撞检测，因为我们仅需得知贪吃蛇是否到达了食物或者红包周围的一定范围，如果是则认为成功了“吃掉”了食物，否则是没有吃到。 所以仅需计算贪吃蛇上每一点与食物、红包之间的距离， Distance 函数返回的是两点之间的距离，所以当apple（即食物）与蛇的坐标之间的距离小于一个定值 appleWidth 时，我们则认为蛇吃到了该食物。分值增加，并且将该食物移除。(a为循环当中的索引) 距离判断： 123456789if (distance(redbag, &#123; x: snake.lastArm.endX(), y: snake.lastArm.endY()&#125;) &lt; bagWidth*1.2) &#123; score += redbag.life; redbags.splice(a, 1); getRebdag = true; addScoreSegments();&#125; 坐标计算思路这种方法的思路是在Canvas画布每一次更新时，计算贪吃蛇每个点下一步所在位置。我们知道了如何画出贪吃蛇之后，就想着如何让“它”动起来。关于贪吃蛇的移动方式大概有以下有两种实现方式：方法①: 计算每一点位置，时时更新：贪吃蛇的移动其实就是每一点的移动。当更新的频率到达一定速率时，人眼便会认为这是“动态”的。吃蛇每个点下一步所在位置,如图所示: 方法②：增加蛇头、删除蛇尾：此方法核心是只计算蛇头下一步所处位置，在移动时增加虽然这一方法计算量小，并且所需储存贪吃蛇信息的数据量也很小，但是这一方法只能适用于每段蛇身长度与移动速度相同的情况。当速度大于蛇身段长时，如图所示，头部每次移动的距离大于一段蛇身长度，每次移动时身体会逐渐分开。反之，当速度小于蛇身段时，贪吃蛇会慢慢重合，最后全部挤在一起。如果是像素风格的贪吃蛇，适用此方法。 性能取舍使用Chrome中Call Tree查看在js脚本中各个方法所占资源。可以看出，对于方法①，其中“绘制”(左图)所占资源远大于“计算”(右图)。因为方法②有一定的局限性，所以首选方法①进行实现，但是担心在低端安卓机会出现帧率不高或者卡顿情况。所以观察方法①中各方法开销。Call Tree可以观察在整个游戏中，各个资源的占用情况。起初我们担心的是由于计算问题导致游戏卡顿，如图所示，在之后实际测试中，发现在整个游戏实际操作上无阻塞感，并且通过Chrome控制台查看Call tree，看看调用了哪些函数，发现主要时间都消耗在fillText、drawImage上，并非是坐标点相关计算函数。所以采用方法① 游戏绘制问题画布跟随旋转当我们想要旋转蛇头时，整个画布也不断的旋转。游戏中贪吃蛇头部朝向需要与贪吃蛇前进方向一致。所以不仅仅是画出蛇头就可以了，还需要让其朝向与前进方向时时对齐。在游戏中已经取得贪吃蛇相对于坐标轴旋转角度，并且Canvas提供旋转方法rotate()，只需将角度传入即可。一切看起来都是这么完美，但是，rotate()方法是将整个画布进行旋转，所以导致一旦贪吃蛇转向时，整个画布都将旋转，便会出现如下情况。 画布旋转： 实现代码： 12ctx.rotate(snake.sgms[length-1].angle);ctx.drawImage(g_source, 0,60,30,30,-snakeWidth/2, -snakeWidth/2, snakeWidth, snakeWidth); 这个时候，又到了save()方法上场，保存当前状态。加上save()后效果如图所示： 实现代码： 123ctx.save();ctx.rotate(snake.sgms[length-1].angle);ctx.drawImage(g_source, 0,60,30,30,-snakeWidth/2, -snakeWidth/2, snakeWidth, snakeWidth); 我们发现，这时候蛇头在左上角一动不动，因为不仅仅需要用save()保存当前状态，还需要将蛇头移动到相应的位置。但在这个时候我们发现，蛇头并没有按照我们想象中那样完美的绑定在头部位置，而是随着贪吃蛇转向而出现一定的偏差。然后发现我们将rotate和translate方法的顺序写反了 先rotate再translate： 1234ctx.save();ctx.rotate(snake.sgms[length-1].angle);ctx.translate(snake.lastArm.endX(),snake.lastArm.endY());ctx.drawImage(g_source, 0,60,30,30,-snakeWidth/2, -snakeWidth/2, snakeWidth, snakeWidth); 将rotate和translate的顺序相调，贪吃蛇的头部已经完全正常了！ 先translate再rotate： 1234ctx.save();ctx.translate(snake.lastArm.endX(),snake.lastArm.endY());ctx.rotate(snake.sgms[length-1].angle);ctx.drawImage(g_source, 0,60,30,30,-snakeWidth/2, -snakeWidth/2, snakeWidth, snakeWidth); 贪吃蛇拐角问题如下面视频所示，贪吃蛇在转向的时候“冒出”了尖锐的拐点：此问题与 Canvas 的 lineJoin 属性有关，此属性是设置或返回两条线相交时，所创建的拐角类型，前文也说过，贪吃蛇是由许多的小线段拼接而成的。所以当贪吃蛇在转向时，相当于线段交汇，所以会出现这种尖锐拐角，通过设置 ctx.lineJoin = “miter” 与 ctx.miterLimit = 1 可以将控制拐角长度，如果斜接长度超过 miterLimit 的值，边角会以 lineJoin 的 “bevel” (斜角)类型来显示。我们将miterLimit 设置为1，再看效果： 游戏问题游戏异常卡顿在所有功能都基本开发完成之后，通过stats.js插件监控游戏帧率，发现游戏在安卓手机上表现异常卡顿。此设备为红米Note3(骁龙650)，正常情况下帧率应该为58-60帧左右。开始怀疑是因为内存泄漏的缘故，但几经排查发现并不是这个原因。最后发现是因为游戏中跑马灯缘故，因为跑马灯不断的在改变 margin-top 值，引起页面一直在重绘，虽然对其单独建立了渲染层，但成效不大，改用translate处理提升也不高。最后解决方案为在进行游戏的时候暂定跑马灯与 Swiper ，在游戏结束后重新开启跑马灯与 Swiper 。 定时器导致卡死游戏中的倒计时功能通过定时器实现，但当定时器内置于游戏逻辑时，再次开始游戏后有一定几率卡死，遂将定时器置于游戏逻辑外，后因为不需要倒计时所以移除了定时器。 游戏性能游戏帧率因为iOS中UI渲染过程具有绝对的优先等级，再加之IOS强大的图形处理器，所以我们首先关心游戏在安卓上的表现情况，如果在安卓上表现流畅，在IOS上表现也不会差。stats.js是一个JavaScript性能监控器。这个类提供了一个简单的信息框，帮助您监控代码的性能。如图所示的深蓝色方框便是stats.js所提供的帧率监控。左边的60FPS为当前渲染的帧率，右侧的60-60分辨是最低帧率-最高帧率。所以可以得出使用一加3T(骁龙821处理器)的手机，在玩贪吃蛇游戏时，最低帧率为60帧，达到了满帧。关于帧率，人眼在15帧能感受到连续的动画，15帧以下看过去是一张张图片，30帧是曾经的标准游戏动画帧数，但是30帧容易引起视疲劳，后来60帧成了标准。30和60肉眼分不出来，但是公认60帧是最好的效果，120帧的游戏也容易引起视觉疲劳，人眼能接受最平衡的数据量就是60帧了，再高你眼睛也采样不过来。30帧和60帧，你连续游戏几个小时就会感受出来区别了 一加3T（骁龙821）通过第三方插件stats.js检测游戏帧率，以下数据为游戏在一加3T手机（2016年下半年旗舰机配置）上的表现情况，如图2-1，可以看出游戏运行情况很好，全程60帧，十分的流畅。 红米Note3（骁龙650）骁龙650在性能上强于骁龙808，弱于810可以很好的代表2016年中端安卓性能。可以看出，游戏全程帧率在58-60之间，也是十分流畅。 魅蓝Note3（联发科 P10）如果说一加3T可以代表2016年安卓旗舰系列，那么拥有Helio P10的魅蓝Note3可以代表2016年上半年千元机的整体实力。虽然在此机型帧率上表现不如前两款机型，但是也有着50-53的帧率，从游戏表现上来说相差无几。 通过对以上几款安卓机型游戏帧率的分析，可以看出，此款游戏在安卓手机上表现还是比较出色的，在游戏时不会感知到明显的卡顿、延迟等，影响用户体验。 内存监测作为一个小游戏，监测其是否存在内存泄漏还是很有必要的。首先通过Chrome控制工具查看在游戏过程中，内存的变化情况，如图表示在整个游戏过程中堆栈占用的情况。如果它变得非常陡峭，说明制造了太多的垃圾；如果它一直处于上升，那么则可能发生内存泄漏。从图中可以看出，并且再通过Chrome工具添加7张内存快照可以发现，整个游戏无内存泄漏风险。 思考与总结Canvas总结本来自身对于Canvas的理解还不够深入，但是在这一次贪吃蛇游戏之后，对于Canvas更加熟悉，例如在Canvas中，如果存在大量的浮点运算时，效率必然下降很多，所以建议将计算的值取整再绘制，对于需要大量渲染的场景中是非常有用的。又例如save()、restore()方法，对于Canvas来说可以说是利器。对于有图像资源并且需要反复DrawImage时，如果没有做好资源载入控制将带来非常严重的显示问题，例如画面闪烁，绘制区域无内容。因此，建议在开发中使用数组或JSON等序列化所有的游戏资源，然后将相关资源一次性建立相关对象，存储在内存中，以便在下载完毕后，频繁读取时不必再去读图片资源，而是直接读内存中的资源，这样一来，一是速度快了许多，二是稳定性有了保障。并对Canvas总结了以下三点： 存在大量浮点计算时，建议取整计算； 对于比较复杂的Canvas，save()、restore()方法可以说是利器 对于有图像资源并且需要反复DrawImage需做好控制。 DrawImage消耗测试因为Canvas具备「把图片中的某一部分绘制到 Canvas 上」的能力，所以很多时候，我们会把多个图片资源对象放在一张图片里面，以减少请求数量。这通常被称为「精灵图」。然而，这实际上存在着一些潜在的性能问题。经测试发现，在绘制相同大小区域的内容时，使用与绘制区域相同大小的图片会比使用精灵图绘制该区域的的开销要小一些。可以认为，两者相差的开销正是「裁剪」这一个操作的造成的。是用一张200200与200600大小的图进行测试，可发现绘制 10000 次一块 200x200 的矩形区域，花费了 42ms；而如果数据源是一200*600 图片中裁剪出来的 200x200 的区域，绘制 10000 次需要花费 59ms。所以虽然看上去开销相差并不多，但是 drawImage 是最常用的 API 之一，所以还是有必要进行优化的。优化的思路是，将「裁剪」这一步骤事先做好，保存起来，每一帧中仅绘制不裁剪。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iPhone X适配]]></title>
    <url>%2F2017%2F07%2F02%2FiPhoneX%2F</url>
    <content type="text"><![CDATA[北京时间 9 月 12 日凌晨，苹果在乔布斯剧院发布了 iPhone X。iPhone X 正面的全面屏上方有一条刘海，对于如何适配 iPhone X，苹果的 Human Interface Guidelines 文档已经给出详细的说明。作为Web端开发者，我们关心如何在苹果给出的适配方案基础上，在我们的App端与H5端表现良好。 本文将剖析我们在App/H5适端配iPhone X的方案。 未做 iPhone X 适配之前的页面 存在的问题： 吸底设置了 bottom: 0 ，但页面的底部依然有空隙，且空隙的内容可发生点击等交互；同样的，弹层设置高度 100%，页面底部也有空隙。 ​ 原因分析： iPhone X 非矩形屏幕，viewport 边界框 与 设备显示区域 不一致。分期乐APP的 webView 默认情况下，viewport 是设备显示区域内的最大矩形框，上下两个圆角矩形的区域成为了 viewport 之外的显示空隙。这些区域由 UA 自动选择显示其认为的合适的内容。 ​解决办法： 通过设置 viewport-fit 来调整 viewport ： 12345auto：这个值不影响初始布局视窗，整个Web页面是可视的。在视窗之外的UA绘制的是未定义的，它可能是画布的背景色，或者是UA认为合适的其他东西contain：最初的布局视窗和视觉布局视窗被设置为最大的矩形。在Viewport之外的UA绘制的是未定义的，它可能是画布的背景色，或者UA认为合适的其他东西cover：初始布局视窗和视觉布局视窗被设置为设备物理屏幕的限定矩形 这儿，我们设置 viewport-fi= cover ，把初始的 viewport 设定为设备物理屏幕受限的矩形： 1&lt;meta name=&quot;viewport&quot; content=&quot;viewport-fit=cover,width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt; 黄色区域于设备显示区域，蓝色+黄色的矩形为 viewport-fit: cover之后的 viewport ，四个蓝色区域为超出可显示区域之外的区域。 ​ 设置之后的页面： 设置之后，吸底和弹窗似乎满足我们的要求的了。但是又出现了新的问题，iPhone X 的底部有系统手势操作区域，吸底与该区域重合是不合理的；吸底的左右边缘文字被圆角矩形遮盖。因此，我们需要把吸底上移，让其离开手势操作区域，又不显示其他背景内容。 ​ 这时，我们可以借助苹果提供的 CSS constant() 来进行下一步操作： 12345constant(safe-area-inset-top)：在Viewport顶部的安全区域内设置量（CSS像素）constant(safe-area-inset-bottom)：在Viewport底部的安全区域内设置量（CSS像素）constant(safe-area-inset-left)：在Viewport左边的安全区域内设置量（CSS像素）constant(safe-area-inset-right)：在Viewport右边的安全区域内设置量（CSS像素）// safe-area-inset 由系统自动提供 webkit官方最新推荐使用 env() 来代替 constant() ，所以，我们给吸底的 div.nav-bottom-wrap 添加： 1234.nav-bottom-wrap&#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom);&#125; 横屏： 从Xcode上的iphoneX模拟器效果可以看出，env()与constant()在横屏模式下生效，但页面在横屏上体验不佳，存在以下几点问题： ① 吸底伴随着页面滑动，吸底会存在偶然下沉或消失的现象。无法判断是模拟器原因还是其他原因(需要在IOS11真机/iPhone X上进行测试)。 ② 针对右侧这种 规则/返回顶部，需要设置右侧的安全距离（旋转后安全距离会按照当前方向的上下左右重新计算，所以可以直接使用safe-area-inset-right)），防止出现图中情况。1234.floating&#123; right: env(safe-area-inset-right); right: constant(safe-area-inset-right);&#125; 但是它的右安全区域在这个位置，大概效果是这样子。会相对于页面的右边向左偏移一点。 针对iphoneX在微信/UC等第三方浏览器中横屏表现，无法进行测试。 ​ 最后呈现的页面： 其他说明： 因为Xcode上iphoneX 横屏全屏情况还未测试，但解决方式应该类似。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>iPhone</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue动画/过渡效果]]></title>
    <url>%2F2017%2F05%2F15%2Fvue-base4%2F</url>
    <content type="text"><![CDATA[Vue中如何实现动画/过渡动画 过渡效果Vue中使用过度效果时，需要在父级包裹一层&lt;transition&gt;&lt;/transition&gt;，并且在name中指明过渡效果的类名，需在CSS中编写 类名-enter,类名-leave 例如：123&lt;transition name="fade"&gt; //name指明了过渡效果的类名，&lt;div&gt;我是一个有过渡效果的块&lt;/div&gt;&lt;/transition&gt; 1234567891011121314/* 可以设置不同的进入和离开动画 *//* 设置持续时间和动画函数 */.slide-fade-enter-active &#123; transition: all .3s ease;&#125;.slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.slide-fade-enter, .slide-fade-leave-to/* .slide-fade-leave-active for &lt;2.1.8 */ &#123; transform: translateX(10px); opacity: 0;&#125;来源： https://cn.vuejs.org/v2/guide/transitions.html 动画动画的实现方式与过渡相同。例如name=”bounce”1234567891011121314151617.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; 设置过渡持续时间在过渡上绑定duration属性可以控制样式存在时间的长短，经过个人测试并不能改变属性变化时间长短，只能在CSS中进行更改。假如Css中未设置transition-duration，会当作0来处理。 钩子函数Vue对次提供了一些钩子函数，用于各个状态的调用，具体如下： 这些钩子函数可以结合CSS transition/animations 使用，也可以单独使用。 当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。 否则，它们会被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。12345678910111213&lt;transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:after-enter="afterEnter" v-on:enter-cancelled="enterCancelled" v-on:before-leave="beforeLeave" v-on:leave="leave" v-on:after-leave="afterLeave" v-on:leave-cancelled="leaveCancelled"&gt; &lt;!-- ... --&gt;&lt;/transition&gt;来源： https://cn.vuejs.org/v2/guide/transitions.html#自定义过渡类名 过度模式当多个元素都具有过度效果时，并且想具有一前一后的过渡效果时，可以使用过度模式实现。有以下两种种过渡模式： in-out ：新元素先进行过渡，完成之后当前元素过度离开； out-in ：当前元素先进行过渡，完成之后新元素过渡进入。123&lt;transition name="fade" mode="in-out"&gt; &lt;div&gt;我是过渡元素&lt;/div&gt;&lt;/transition&gt; 更过过渡的效果更多过渡 与其他组件配合]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hio预研]]></title>
    <url>%2F2017%2F05%2F12%2Fhilo%2F</url>
    <content type="text"><![CDATA[背景2014年，一个HTML5游戏——“围住神经猫”以病毒式增长速度刷爆了朋友圈，之后HTML5小游戏就开始一发不可收拾。经过一段时间的酝酿，各个优质的H5纷纷占领各自的朋友圈，如淘宝《穿越整个宇宙向你发来的一封双11邀请函》，腾讯《薛之谦史上最疯狂广告》，天天P图《我的小学生证件照》等等，连起来可以绕地球好多圈。根据ih5报告可以看出，去年一年游戏H5占比达到了23.9%。而休闲类手游不再以制作精良而取胜，各种奇葩玩法的简单游(微博)戏反而得到用户欢迎。这些H5一般只做目的是促销活动、新品发布，本质上采取的是游戏化营销战略。 详细信息可以查看：2016年度H5最全报告 前期调查及方案根据2016年 最火的15 款 HTML5 游戏引擎.可以得到去年一年比较热门的免费HTML5游戏框架，共十五款，各个数据如下 Name Updated Time Watch Star Fork Commits Contributors Three.js 2016/3/28 1590 24041 7768 14825 588 Phaser.js 2016/2/18 837 11782 4095 4423 206 Pixi.js 2016/3/17 656 10063 1942 2860 161 egret 2016/3/30 215 1275 303 4268 25 enchantjs.js 2016/1/4 185 1445 301 1683 27 crafty 2016/3/21 134 2050 473 1807 106 turbulenz 2015/11/23 271 2544 406 1737 13 cocos2d-js 2016/3/30 162 1207 469 4559 45 playcanvas 2016/3/30 164 1784 368 5142 16 melon.js 2016/3/30 13 1579 371 390 40 quintus 2016/2/03 136 1023 412 256 33 Hilo 2016/2/03 173 2449 340 20 2 因为业务核心点为营销，无需开发大型重量级H5游戏，所以选择其中较为轻量的框架。所以放弃如Egret(白鹭)引擎等，尽管其拥有着良好的中文文档与开发者社区。又例如Three.js，体积约490KB，拥有着高性能的3D WebGL效果，并且能够让我们无需关注webgl实现方式，写出特别炫酷的效果，但相对的是其入门难度高，并且中文资料老旧，网络上Three.js方面的资料比较散乱且良莠不齐，部分中文文档翻译低级错误频出，英文文档本身比较简陋且有不少拷贝错误。Pixi.js约358KB，与Three.js相同的是，其拥有着高性能的WebGL模式2D渲染引擎，但是也是英文文档；而Hilo的设计思路更加偏向前端开发者以及简单的营销活动小游戏。经过压缩后体积约65KB，相对于上面两个来说，已经算十分的轻量了。并且拥有中文文档，对于中文开发者来说十分友好，且已经经历多届阿里巴巴双十一，年中大促互动营销活动考验。对于我们业务来说，只需要适配对canvas和css3支持度良好的高级浏览器或者webview，直接使用Hilo基础渲染器而无需在引入其他模块，做到了体积最小。 预研框架概述借用Hilo Github上原话：Hilo 是阿里巴巴集团开发的一款HTML5跨终端游戏解决方案，ta可以帮助开发者快速创建HTML5游戏。官方宣传的其主要特性有一下几点： Hilo 支持多种模块范式的包装版本，包括AMD，CMD，COMMONJS，Standalone多种方式接入。另外，你可以根据需要新增和扩展模块和类型； 极精简的模块设计，完全面向对象； 多种渲染方式, 提供DOM，Canvas，Flash，WebGL等多种渲染方案（目前已经申请专利）； 全端浏览器的支持和高性能方案，独有的Flash渲染方案，即使在低版本IE浏览器下也可以跑起来“酷炫”游戏； DOM渲染方案能显著解决低性能手机浏览器遇到的性能问题； 物理引擎支持——Chipmunk，支持自扩展物理实现；骨骼动画支持——DragonBones，同时内建骨骼动画系统——Tahiti（目前内部使用）； 案例丰富，框架成熟，已经经历多届阿里巴巴双十一，年中大促互动营销活动考验；其余详细信息可参见其Github官网 再经过通过其他的一些相关资料收集，总结出Hilo对于开发人员来说的一些优点： 支持canvas dom webgl 三种渲染方式（官方说有FLASH），希望未来的版本能够自适应浏览器，这将是一个巨大的亮点！ 支持Canvas的位移，Transform等常见动画效果。 支持导入图片、绘制常见形状等，并且，支持SVG绘图。 支持2D、伪3D。 支持WebGL ，目前没有实现相关3D模型的封装。 自带粒子系统、缓动函数，WebSound可以自适应各种平台。 对于静态、复杂的场景，自动使用DIV潜入静态图片或文字，以提升效率（比如背景图片）。 在经过预研之后，发现Hilo无疑是对我们现在业务来讲最为合适的轻量游戏框架，为了对其进行更深一步研究，仿照双十一红包雨，使用Hilo进行实现，探究其内部的内容。以下列出几点两者实现方式对比（因为整体红包雨实现逻辑不同，所以仅列举部分进行比较）： 补间动画：补间是一个概念，允许您以平滑的方式更改对象的属性值。您只需要知道要更改哪些属性，当补间程序运行结束时应该具有哪些最终值，以及应该花费多长时间，补间引擎将会从开始到结束点处理中间值。双十一红包雨补间动画计算与移动是通过人工编写，代码如下：Hilo红包雨补间动画计算与移动则通过Tween.js进行计算，并且提供多种的缓动功能，如线性，二次，立方，四分，五次，正弦，指数，圆形，弹性，反向和反弹等。调用代码如下：可以看出，原生实现的优势在于可以减少引入代码量，但却要增加手写工作量；而引入Hilo(集成了Twenn.js)优势在于可以少写很多代码，但缺点是增加了页面体积。 资源加载： 双十一红包雨自己编写资源加载器。如图:Hilo已经为我们封装好相应的资源预加载模块，如图: 资源管理:双十一红包雨通过将一系列素材以及素材状态放入数组进行管理，后续需要人为的去更新、删除等。如图:而通过使用Hilo，可以不用关心素材管理，通过将素材挂载在创建的Container中，Hilo为我们自动化的进行管理。 素材添加： 双十一红包雨同样是通过原生canvas方法实现。如图Hilo红包雨则是通过Hilo提供的位图方法建立红包,节省编码时间，如图 最终效果：最终两者效果如下 在完成仿制红包雨后，总结了一些Hilo的优缺点（仅针对个人在实验过程中发现的优缺点，并不能代表整个框架的优缺点） 优点： 学习之后，可以进行快速的轻量级互动游戏类页面开发。 对于前端开发者来说，学习成本较其他低。 相较于其他互动游戏解决方案，Hilo总体只有60多KB。 整合了Tween,Ease，具有缓动效果。 具有中文Api文档，对中文开发者友好。 缺点： API文档略简洁，实例相对较少，困难解决成本相对较高。 一些功能并不完善，例如drag拖动等（开始拖动时，被拖动元素并不是自动的提升到最高层级，会被其他更高层级物体盖住）。 部分方法内部实现方式略简单粗暴。 ##拼图预热活动 需求效果： 传入一张整图，等分九宫格 可以在边界内自由进行拖拽，当进入九格中任意一格时，取消拖拽事件后能完美的放置于格子中。 拖拽完成后无法在进行拖拽。 具有定时器，计步等功能。 思路 拼图图像初始化： 创建一个Container容器用于放置拼图内容，针对非正方形图片进行拉升。在Hilo中，Container是所有容器类的基类。每个Container都可以添加其他可视对象为子级。相较于使用Canvas需要设置繁多，在Hilo中只需要实例化一个Container容器用于放置素材并设置属性就行了。 根据传入参数进行分割（如33/44等），位置随机但不会出现一开始拼图就完成的情况。在位置进行变化时使用Hilo中整合的Tween.js自动创建补间动画，使拼图块移动自然不生硬。 拼图拖拽 对分割的图象绑定拖拽事件，每次拖拽完成都会判断一次游戏是否结束，当游戏结束时将游戏状态返回。这里使用Hilo封装好的拖拽函数startDrag，开始监听拖拽事件,如图 此处有一难点，如何在用户拖动拼图的时候自动吸附到对应的格子。出于游戏体验与扩展性，在游戏初始化时将图像分割数限定在了&gt;=2，&lt;=4这一范围，所以拖动的格子不会大于4，所以拟合一个多次方程，使其满足：传入图像本身移动距离，输出图像应该移动的距离，使其只能移动到事先分割的格子中，并且当进入一定范围内，松手图片可以完美的放置在格子中。 每一次成功的图像交换，步数加一。 当游戏结束，删除拖拽事件。Hilo使用stopDrag停止监听拖拽事件： ###实现效果 ###性能因为Hilo整体体积约65KB，通过Chrome控制台观察，在模拟常规4G网络速度加载的情况下，大概花费了721ms，在Wifi情况下加载时间约为100ms。在拼图初始化时，通过Hilo的Ticker函数将运行帧率控制在24帧左右，在这一帧率人体肉眼可以看到连续画面不会出现卡顿感，并且相比于高帧率可以有效的降低性能消耗。在通过Chrome工具Timeline观察可知，在拼图初始化过程中，运行帧率也是在24帧左右,可以流畅的运行。 扩展/兼容性 每个大功能模块皆挂载在window.game下，不造成变量污染。 理论上可以做到任意NN个分割，但不建议分割为44以上。 针对不是正方形的图片进行了拉伸处理。 总结经过两个项目的开发，个人认为hilo作为一款轻量级的营销游戏类H5引擎还是不错的，能够帮助我们减轻开发负担，提高开发效率；但毕竟没有对Hilo进行更多的研究，其中也有很多其他的坑是还没有踩到的，根据网上其他的开发者的描述来说，Hilo还是有很多不足之处，也希望开发者能够更多的完善它。 参考资料 2016年度H5最全报告：原来这行水这么深 Hilo官方网站 2016年最火的15款HTML5 游戏引擎]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web AR 预研二三事]]></title>
    <url>%2F2017%2F04%2F27%2Far_web1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;AR：增强现实（Augmented Reality，简称AR）：是一种实时地计算摄影机影像的位置及角度并加上相应图像、视频、3D模型的技术，这种技术的目标是在屏幕上把虚拟世界套在现实世界并进行互动。 &emsp;&emsp;本文将探究Web AR的可行性与实现。 实现分析既然是手机AR，那么意味着有两个前提 H5 意味着在手机而非 PC 上实现 AR 意味着需要获取实时的视频流目前 Web 中实现 AR 都需要开启摄像头（手机具有先天优势），而获取实时视频流。然后再将虚拟物体以某种方式结合到画面中。综合考虑，可以得出实现一个Web AR大概需要经历以下步骤： 获取视频源 将虚拟物体叠加在视频源上 将最终画面显示在屏幕上 用户与设备进行交互 技术分析获取视频浏览器可以用过navigator.getUserMedia()这一API获取用户的摄像头数据流与麦克风数据流（Stream）。在使用该API时，我们发现该API已被废弃。通过MDN查询该API资料可得：其新的标准是 接口来调用 方法，该方法通过提示用户，让用户选择是否打开系统上的相机或麦克风等，并提供包含音视频的 MediaStream。但经过尝试，仍未解决在安卓webkit内核浏览器中调用后置摄像头问题，使用一实验性方法mediaDevices.enumerateDevices()，此API仅能在支持ES6语法的手机上运行。12345navigator.mediaDevices.getUserMedia(constraints).then(function(stream) &#123; // 对媒体流进行处理&#125;).catch(function(err) &#123; // 对错误进行处理&#125;); 注：IOS不支持调用摄像头，webkit内核浏览器调用摄像头需通https。 constraints需要请求的媒体类型对象，如{audio: true, video:true} { audio: true, video: { facingMode: { exact: “environment” } } }。在实际操作过程中，我们发现即便是传入的参数强制指定为后置摄像头，在安卓手机QQ等一些 或浏览器中并不能生效。因此我们需要通过强制指定请求媒体的设备id来实现打开后置摄像头。方法如下 核心代码如下：1234567891011121314151617181920212223242526navigator.mediaDevices.enumerateDevices() // 调设备信息.then(function(devices) &#123; devices.forEach(function(device) &#123; if (device.label.indexOf('back') &gt; 0 || device.kind == 'videoinput') &#123; _this.videoId = device.deviceId // 获取后置摄像头 id &#125; &#125;)&#125;).then(function() &#123; var constraints = &#123; "video": &#123; optional: [&#123; sourceId: _this.videoId &#125;] &#125;, "audio": false &#125;; try &#123; navigator.mediaDevices.getUserMedia(constraints) // 调起后置设置摄像头 .then(_this.successFunc) .catch(_this.oldGetUserMedia) &#125; catch (error) &#123; // 开启全景背景图 _this.initBg(); &#125;&#125;) 通过 mediaDevices.enumerateDevices()方法来获得设备上所有的媒体输入和输出设备信息，比如摄像头，麦克风等。通过枚举这些设备，判断设备标签（device.label）中是否有 back 关键词来获取后置摄像头的设备id device.deviceId。 device.kind == ‘videoinput’ 是对 firefox 的兼容处理，因为 firefox 中的 device.deviceId 为空。获取设备id信息后，再构造 constraints 对象使用，即通过 optional 指定 sourceId 为指定的设备id。注意：mediaDevices.enumerateDevices() 目前还处于试验性标准阶段，实现该方法的浏览器目前还不多。对于不支持此方法的，我们直接不做调起后置摄像头的尝试，转而使用3D全景图。 其中使用了ES6所具有的方法与语法，相关方法支持度如图黑色框： 可以看出，IOS9以及安卓5.1以上的版本支持友好。对于不支持ES6的设备，调用3D全景图进行替换。 3D全景图对于不支持调用摄像头的设备，我们输出3D全景图对其进行兼容。考虑到以后模型等使用three.js进行建立，所以3D全景我们也使用three.js来制作。通过three.js构造一个球体，将全景图片作为材质对其进行贴合。全景图示例：创建球形3D全景核心代码如下：12345678910111213texture = THREE.ImageUtils.loadTexture(_this.Img_id.src, &#123;&#125;, function () &#123; var geometry = new THREE.SphereGeometry(r, 100, 100); //构造球体 var material = new THREE.MeshLambertMaterial(&#123; //传入贴图材质 map: texture, side: THREE.DoubleSide &#125;); var mesh = new THREE.Mesh(geometry, material); //构建三位网格模型 _this.Scene.add(mesh); //添加到场景之中 mesh.position.set(0, 0, 0); var light = new THREE.AmbientLight(0xffffff); //全局光 _this.Scene.add(light);&#125;); 考虑到用户进入页面时候的手机角度有各种情况，可能是竖着手机进入，然后平放手机等待加载完成查看页面……并且为了降低交互难度以及固定让3D模型出现在舞台上（背景比较好看的情况下），需要的是在不同朝向（东南西北）打开3D全景，都是看向一个固定方向的。强制其朝向同一个方向。1_this.Camera.lookAt(&#123; x: 200, y: 0, z: 0 &#125;); 陀螺仪绑定无论是AR亦或是VR，其核心交互少不了根据所持设备方向变换而展示不同场景，这其中的核心便是根据陀螺仪改变场景。DeviceOrientationControls.js– 这是一个 three.js 插件，它帮助我们完成之前提到过的监视设备朝向，并且代码量非常少，通过它我们可以省去将陀螺仪alpha、beta、gamma值计算为我们所需值的步骤。代码如下：1234initDevices:function()&#123; var _this = this; _this.Devices = new THREE.DeviceOrientationControls(_this.Camera);&#125; 用户与设备交互目前实现了两种交互方式 1. 用户通过移动手机，使手机中心点与我们设立的目标事物某一点对齐，完成交互。 实现思路是通过监听陀螺仪数据与目标事物当前的位置通过一定的计算进行对比。当到达某一临界值，判断其对齐成功。 具体代码如下：123456789101112rx=Math.round(camera.getWorldDirection().x*1000); //当前位置信息ry=Math.round(camera.getWorldDirection().y*1000);rz=Math.round(camera.getWorldDirection().z*1000);dx=Math.round(Devices.deviceOrientation.alpha); //陀螺仪信息dy=Math.round(Devices.deviceOrientation.beta);dz=Math.round(Devices.deviceOrientation.gamma);renderer.render(scene, camera);if(rx/dx&lt;0 &amp;&amp; rx/dx&gt;-0.5 &amp;&amp; ry/dy&gt;-0.5 &amp;&amp; ry/dy&lt;0.5)&#123; //符合条件调用success方法 succes();&#125; 用户通过点击屏幕进行交互在页面中插入3D模型，不光只是为了看，更重要的是实现交互，比如点击，拖拽等。在 Three.js 模型中实现点击操作，可以使用 Three.js 自带的射线检测（ Raycaster ）。 其原理是：在用户点击时，获取点击点的屏幕坐标；根据场景中照相机，将屏幕坐标转换成场景中的坐标；新建一条从照相机位置，向转换后的场景坐标位置射出一条射线（向量），检测这条射线穿过的场景中的物体。关键代码：123456789101112131415161718192021222324252627// 实例化射线检测_this.raycaster = new THREE.Raycaster(); rayCheck: function() &#123; var _this = this; // 传入touch坐标 和 照相机 _this.raycaster.setFromCamera(_this.tempTouch, _this.camera); // 射线检测是否穿过指定物体 // _this.scene.selectable 是一个场景需要检测的物体的数组，在往_this.scene添加物体时push进去的 // intersects 射线与被检测物体相交的物体对象 var intersects = _this.raycaster.intersectObjects(_this.scene.selectable, true); if (intersects.length &gt; 0) &#123; alert("中奖啦"); _this.isTouched = true; // todo other &#125;&#125;,initEvent: function() &#123; var _this = this; document.addEventListener('touchend', function(event) &#123; // touch结束时，touch 横坐标到屏幕左侧的距离与屏幕宽度的一半的比值，绝对值不超过1 _this.tempTouch.x = (event.changedTouches[0].clientX / window.innerWidth) * 2 - 1; // touch结束时，touch 纵坐标到屏幕顶部的距离与屏幕高度的一半的比值，绝对值不超过1 _this.tempTouch.y = -(event.changedTouches[0].clientY / window.innerHeight) * 2 + 1; &#125;, false);&#125;, 这是里涉及到Three.js里的两个坐标系，世界坐标系和屏幕坐标系。屏幕坐标系是原点基于窗口左上角的坐标系。Threejs的世界坐标系与openGL的世界坐标系相同，以屏幕中心为原点（0，0，0），并且始终不变。面对屏幕，右边为x轴的正轴，上面为y轴的正轴，屏幕向上的地方为z轴的正轴。也称为右手坐标系。 结语新技术的预研一路上会遇到很多坑，当解决了这个问题之后又会发现出现了新问题。不过踩的坑越多，才能知道越多]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>three.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue生命周期]]></title>
    <url>%2F2017%2F04%2F23%2Fvue-base2%2F</url>
    <content type="text"><![CDATA[生命周期Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据观测(data observer)、编译模版、挂载实例到 DOM ，然后在数据变化时更新 DOM 。在这个过程中，实例也会调用一些 生命周期钩子 ，这就给我们提供了执行自定义逻辑的机会。例如，created 这个钩子在实例被创建之后被调用：类似的还有mounted、updated、destroyed特别值得注意的是created钩子函数和mounted钩子函数的区别123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;, created: function () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a) &#125;&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue属性与方法]]></title>
    <url>%2F2017%2F04%2F15%2Fvue-base1%2F</url>
    <content type="text"><![CDATA[数据绑定 数据绑定使用 的格式绑定数据 数据双向绑定 v-model12v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。vuejs双向绑定并不能适用于所有的html表单，限制为input、select、textarea、components。 v-text 整个标签绑定在vuejs中可以使用v-text属性来控制整个标签的内容绑定。 v-htmlv-html 更新元素或者变量的innerHTML，按普通html解析，和v-text的区别是在变量中的html标签会被浏览器解析，比如&lt;br&gt;会直接解析为换行直接作为 HTML —— 数据绑定会被忽略。注意，你不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容插值。 v-showv-show 根据条件解析元素display的属性的真假，如果为真则display为block，假的话则为none在页面不显示。 v-ifv-if、v-else、v-else-if,if三兄弟，条件判断，这个跟我们平时见到的if语句类似，根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。 v-for循环遍历 v-on事件绑定 1234567891011121314151617&lt;!-- 方法处理器 --&gt;&lt;button v-on:click="doThis"&gt;&lt;/button&gt;&lt;!-- 内联语句 --&gt;&lt;button v-on:click="doThat('hello', $event)"&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click="doThis"&gt;&lt;/button&gt;&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop="doThis"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent="doThis"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent="doThis"&gt;&lt;/button&gt;&lt;!-- 键修饰符，键别名 --&gt;&lt;input @keyup.enter="onEnter"&gt;&lt;!-- 键修饰符，键代码 --&gt;&lt;input @keyup.13="onEnter"&gt; v-oncev-once 能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上所有的数据绑定 1&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125; &lt;/span&gt; 计算属性computed意为计算属性，注意，是属性！！！然后methods意为方法。var obj = { name:’hello’, shake:function(){}}name是obj的成员属性，而shake是obj的成员方法。 我们可以将同一函数定义为一个 method 而不是一个计算属性。对于最终的结果，两种方式确实是相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。指令 参数一些指令能够接受一个“参数”，在指令后以冒号指明。例如，v-bind指令被用来响应的更新HTML属性。下面是a标签中href参数，告知v-bind指令将钙元素的href属性与表达式url的值绑定。1&lt;a v-bind:href="url"&gt;&lt;/a&gt; 另一个例子v-on，用于监听DOM事件123456&lt;a v-on:click="doSome"&gt;&lt;/a&gt;+ 修饰符修饰符(Modifiers)是以半角句号 `.` 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如,`.prevent` 修饰符告诉 `v-on` 指令对于出发的事件调用'event.preventDeafult()'：```html&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt; 过滤器可用于一些常见文本的格式化。可用于插值和v-bind(Vue2.1.0开始支持)表达式。12345&lt;!-- 插值 --&gt;&#123;&#123; msg | capitalize&#125;&#125;&lt;!-- b-bind --&gt;&#123;&#123;div v-bind:id="sth | formatId"&#125;&#125; 12345678910new Vue(&#123; // ... filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;) 过滤器可以串联：1&#123;&#123; msg | filterA | filterB &#125;&#125; 过滤器是 JavaScript 函数，因此可以接受参数：这里，字符串 ‘arg1’ 将传给过滤器作为第二个参数， arg2 表达式的值将被求值然后传给过滤器作为第三个参数。1&#123;&#123; msg | filterA( 'arg1' , arg2 ) &#125;&#125; 缩写 v-bind当我们需要用到v-bind，使，可以使用:替代 12345&lt;!-- 完整写法 --&gt;&#123;&#123;div v-bind:id="sth | formatId"&#125;&#125;&lt;!-- 缩写--&gt;&#123;&#123;div :id="sth | formatId"&#125;&#125; v-on 12345&lt;!-- 完整写法 --&gt;&#123;&#123;div v-on:click="doSth" &#125;&#125;&lt;!-- 缩写--&gt;&#123;&#123;div @:click="doSth" &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用整理-H5]]></title>
    <url>%2F2017%2F04%2F02%2Ftest%2F</url>
    <content type="text"><![CDATA[此文为在工作中遇到一些需要复用或者常见的代码收集 开头1234567@ppr: 75px/1rem;body&#123; max-width: 750px/@ppr; margin-left: auto; margin-right: auto; background-color: XXXXX;&#125; 占位图http://www.fenqile.com/dummy/image/690x200 标题文字隐藏12345.movie-h3&#123; line-height:0; font-size:0; overflow:hidden; &#125; 默认透明图1&lt;img data-src="./img/coupon.png" src="//cres2.fenqile.cn/sale/img/core/pc/default.png" class="imgauto"&gt; 公共底部.com-bottom-wrap{padding-bottom:2 rem!important} background1234background-image: url(../img/diamond.png);background-position:0 -157.5px;background-repeat: no-repeat;background-size: 19px auto; 兼容IE7 8 9的背景遮罩123&lt;div class="demo"&gt; &lt;p&gt;背景透明，文字不透明&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718.demo&#123; padding: 25px; background-color: rgba(0,0,0,0.5);/* IE9、标准浏览器、IE6和部分IE7内核的浏览器(如QQ浏览器)会读懂 */&#125;.demo p&#123; color: #FFFFFF;&#125;@media \0screen\,screen\9 &#123;/* hack,只支持IE6、7、8 */ .demo&#123; background-color:#000000; filter:Alpha(opacity=50); position:static; /* IE6、7、8只能设置position:static(默认属性) ，否则会导致子元素继承Alpha值 */ *zoom:1; /* 激活IE6、7的haslayout属性，让它读懂Alpha */ &#125; .demo p&#123; position: relative;/* 设置子元素为相对定位，可让子元素不继承Alpha值 */ &#125; &#125; 吸底箭头动画 需修改,将before位置放置在span之后，不然会影响效果 example 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384span&#123; position: relative; display: inline-block; width: .2rem; height: .2rem; border-width: .07rem; border-style: solid; border-color: currentcolor currentcolor transparent transparent; -webkit-transform: rotate(45deg); transform: rotate(45deg); margin-left: 0; opacity: 1; -webkit-animation: run 2s infinite; animation: run 2s infinite; &amp;:before, &amp;:after&#123; position: absolute; content:''; width: .2rem; height: .2rem; border-width: .07rem; border-style: solid; border-color: currentcolor currentcolor transparent transparent; &#125; &amp;:before&#123; top: -8px; left: 4px; opacity: .5; -webkit-animation: run1 2s infinite; animation: run1 2s infinite; &#125; &amp;:after&#123; top: -14px; left: 10px; opacity: .28; -webkit-animation: run2 2s infinite; animation: run2 2s infinite; &#125;&#125;/* 兼容ipad分辨率 */@media screen and (min-width:768px)&#123; .XXX父层&#123; span&#123; &amp;:before&#123; top: -17px; left: 7px; &#125; &amp;:after&#123; top: -29px; left: 19px; &#125; &#125; &#125;&#125;@keyframes run&#123; 0&#123;opacity: 1;&#125; 50%&#123;opacity: 0;&#125; 100%&#123;opacity: 1;&#125;&#125;@-webkit-keyframes run&#123; 0&#123;opacity: 1;&#125; 50%&#123;opacity: 0;&#125; 100%&#123;opacity: 1;&#125;&#125;@keyframes run1&#123; 0&#123;opacity: .6;&#125; 50%&#123;opacity: 0;&#125; 100%&#123;opacity: .6;&#125;&#125;@-webkit-keyframes run1&#123; 0&#123;opacity: .6;&#125; 50%&#123;opacity: 0;&#125; 100%&#123;opacity: .6;&#125;&#125;@keyframes run2&#123; 0&#123;opacity: .4;&#125; 50%&#123;opacity: 0;&#125; 100%&#123;opacity: .4;&#125;&#125;@-webkit-keyframes run2&#123; 0&#123;opacity: .4;&#125; 50%&#123;opacity: 0;&#125; 100%&#123;opacity: .4;&#125;&#125; CSS倒影1234img&#123; -webkit-box-reflect: below 0 -webkit-linear-gradient(rgba(250, 250, 250, 0), rgba(250, 250, 250, 0) 30%, rgba(250, 250, 250, 0.3)); box-reflect: below 0 linear-gradient(rgba(250, 250, 250, 0), rgba(250, 250, 250, 0) 30%, rgba(250, 250, 250, 0.3));&#125; swiper组件123456789&lt;script&gt; seajs.use(['swiper/h5/1.0.0/swiper.js'], function(Swiper)&#123; var swiper = new Swiper('.swiper-container', &#123; direction : 'horizontal', autoplay : 5000, slidesPerView : 3 &#125;); &#125;);&lt;/script&gt; CSS锯齿123456789101112131415&lt;style type="text/css"&gt;.toothbg&#123;width:100%;height:20px;background:#41B61A; background-image:-webkit-gradient(linear,50% 0,0 100%,from(transparent), color-stop(.5,transparent),color-stop(.5,#e5e5e5),to(#e5e5e5)), -webkit-gradient(linear,50% 0,100% 100%,from(transparent), color-stop(.5,transparent),color-stop(.5,#e5e5e5),to(#e5e5e5)); background-image:-moz-linear-gradient(50% 0 -45deg,transparent,transparent 50%,#e5e5e5 50%,#e5e5e5), -moz-linear-gradient(50% 0 -135deg,transparent,transparent 50%,#e5e5e5 50%,#e5e5e5); background-size:30px 15px; background-repeat:repeat-x; background-position:0 100%; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="toothbg"&gt;&lt;/div&gt;&lt;/body&gt; 悬浮窗关闭按钮一般写法123456789101112131415161718192021222324252627282930313233.close-btn&#123; position: absolute; top: 5px; right: 6px; width: 29px; height: 29px; span&#123; position: relative; display: block; width: 100%; height: 100%; -webkit-transform: rotate(45deg); transform: rotate(45deg); &amp;:before&#123; content: ""; position: absolute; top: 14px; left: 4px; width: 21px; height: 1px; background-color: #808080; &#125; &amp;:after&#123; content: ""; position: absolute; top: 4px; left: 14px; height: 21px; width: 1px; background-color: #808080; &#125; &#125;&#125; li非等高布局示例 1234567&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt; 123ul&#123; width:100%;&#125;li&#123;width:25%;float:left; height:30px;&#125;li:first-child&#123; width:50%; height:60px;&#125; 爆品区123&lt;div class="page-titile"&gt; &lt;h2&gt;最热&amp;nbsp;&lt;em&gt;爆品区&lt;/em&gt;&lt;/h2&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435.page-titile&#123; position: relative; width: 100%; height: 150px/@ppr; .page-sprite; background-position: 0 0; h2&#123; .cen-trans(both); top: 60%; display: inline-block; height: 45px/@ppr; line-height: 45px/@ppr; padding:0 10px; font-size: 40px/@ppr; font-weight: bold; color: #fee352; em&#123; color: #fff; font-weight: bold; &#125; &amp;:before, &amp;:after&#123; position: absolute; top: 33%; width: 90px/@ppr; height: 15px/@ppr; content:''; display: inline-block; .page-sprite; background-position: -90px/@ppr -160px/@ppr; &#125; &amp;:before&#123; left: -90px/@ppr; &#125; &amp;:after&#123; right: -90px/@ppr; &#125; &#125; &#125; 返回顶部12345&lt;!-- 返回顶部[[ --&gt;&lt;aside class="page-go-top js-go-top"&gt; &lt;span&gt;&lt;/span&gt;&lt;/aside&gt;&lt;!-- 返回顶部]] --&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* 返回顶部 */.page-go-top&#123; display: block; width: 44px; height: 44px; opacity: .8; border-radius: 50%; position: fixed; bottom: 50px; right: 10px; z-index: 10; border: 1px solid #666; background-color: rgba(255,255,255,.75); &amp;:before&#123; content: ""; width: 8px; height: 8px; border-style: solid; border-color: #929292; border-width:2px 2px 0 0; display: block; position: absolute; left: 50%; margin-left: -5px; top: 14px; -webkit-transform:rotate(-45deg); -moz-transform:rotate(-45deg); -ms-transform:rotate(-45deg); transform:rotate(-45deg); &#125; &amp;:after&#123; content: ""; width: 2px; height: 14px; background-color: #929292; display: block; position: absolute; left: 50%; margin-left: -1px; top: 14px; &#125; span&#123; position: absolute; top: 8px; left: 13px; width: 18px; height: 2px; background-color: #929292; &#125; p&#123; position: absolute; bottom: 2px; width: 100%; text-align: center; font-size: 10px; color: #666; &#125;&#125; $ad_pic = $config[&apos;ad_pic&apos;]; &lt;section class=&quot;page-pic&quot;&gt; &lt;div class=&quot;pic-wrap&quot;&gt; &lt;?php foreach ($ad_pic[&apos;top&apos;] as $item) :?&gt; &lt;a href=&quot;&lt;?php echo $item[&apos;link&apos;];?&gt;&quot; class=&quot;pic_two&quot;&gt; &lt;img data-src=&quot;&lt;?php echo $item[&apos;img_src&apos;]?&gt;&quot; src=&quot;//cres2.fenqile.cn/sale/img/core/h5/default.png&quot; class=&quot;imgauto&quot;&gt; &lt;/a&gt; &lt;?php endforeach ?&gt; &lt;/div&gt; &lt;div class=&quot;pic-wrap&quot;&gt; &lt;?php foreach ($ad_pic[&apos;bottom&apos;] as $item) :?&gt; &lt;a href=&quot;&lt;?php echo $item[&apos;link&apos;];?&gt;&quot; class=&quot;pic_three&quot;&gt; &lt;img data-src=&quot;&lt;?php echo $item[&apos;img_src&apos;]?&gt;&quot; src=&quot;//cres2.fenqile.cn/sale/img/core/h5/default.png&quot; class=&quot;imgauto&quot;&gt; &lt;/a&gt; &lt;?php endforeach ?&gt; &lt;/div&gt; &lt;/section&gt; &lt;!-- 广告位]] --&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css动画制作相关思考]]></title>
    <url>%2F2017%2F03%2F07%2Fcss_animate%2F</url>
    <content type="text"><![CDATA[现目前，CSS动画十分的普遍，但什么是一个好的动画呢？动画的不同实现方式对浏览器又有什么影响？这是一个值得思考的问题 针对本人做过的一个Css动画与收集的相关资料，输出相关思考。 如何将动画性能最优,不影响页面流程。尽量使用CSS3来书写动画。 对于chrome及其内核来说，渲染线程分为main thread和compositor thread。如果CSS动画只是改变transform 和opacity，这时整个CSS动画得以在compositor thread完成（而JS动画则会在main thread执行，然后触发compositor 进行下一步操作） 在JS执行一些昂贵的任务时，main thread繁忙，CSS动画由于使用了compositor thread可以保持流畅使用CSS3书写动画的时间成本比使用JS书写动画的时间成本低，并且在后续修改中相对更改难度低，性能调优方向固定。 CSS3有兼容性问题，而JS大多时候没有兼容性问题。 CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件。 CSS可以促发GPU加速，这样仅触发Composite，不触发layout或paint,其中详见以前的分享的一个链接，浏览器渲染坑——无线性能优化Composite 对于不影响感官体验的部分，做到尽可能的图片压缩。如果为春季三月开学大促主会场banner的gif图：各动画效果如下可以看出，此动画的难点一共有三，过山车、左下扭动的猫头鹰，以及在下方往返的购物车，不过随后设计放弃下方往返购物车，改为其他动效。针对以上动效，由于过山车与左下扭动的猫头鹰无法使用常规CSS实现而是用雪碧图实现。两张图尽可能压缩后由总共433KB降为77KB，一共减少了82%的体积。如图：针对剩余元素，全部使用雪碧图进行拼合。但对于中间偷窥的粉色企鹅，如果将中间一大块扣出的话，无疑会增加图片体积，对于需要首屏快速加载的大促主会场来说，无疑是一个大负担。所以针对这里，采用改变粉色企鹅background-position的属性，达到gif动效的效果。主会场的sprite如图1-3(因原图略长，截取部分图像)：共计28.3KB。综上，此次banner动画部分加上背景70KB一共需加载170KB左右素材，同时能展示出丰富的动效。 合理书写动画效果。 合理使用GPU加速合理使用GPU加速告诉浏览器使用GPU对其渲染，减少CPU渲染压力，释放CPU资源对其他线程进行支持。 如何触发GPU加速？CSS中一些属性（如transition、CSS3 3D transforms、Canvas、WebGL、Video等）能用来触发GPU渲染，详见 无线性能优化：Composite 合理触发Composite如图，通过Chrome浏览器的开发者工具可以查看页面元素重绘区域、合成层等，如何使用详见– Chrome渲染分析之Rendering工具使用 打开Rendering中的Layer Borders，查看页面中的合成层，更加详细的情况可以在Timeline中查看（ 无线性能优化：Composite 文中对这一点也有讲诉，此处不再赘诉），查看其中影响性能的地方(例如内存占用、重绘等)，然后根据自己需要，对其进行相关优化（例如，主会场中banner牺牲了部分性能换取了更小的图片加载）。虽然提升合成层会达到更好的性能，这看上去十分美好。但是，创建一个新的合成层并不是免费的，它得消耗额外的内存和管理资源。实际上，在内存资源有限的设备上，合成层带来的性能改善，可能远远赶不上过多合成层开销给页面性能带来的负面影响（试想一下，创建成百上千个合成层，导致内存不断的飙升）。而且因为每个渲染层的纹理都需要上传到 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题。所以合理的创建合成层是十分有必要的，具体情况还需要看实际项目情况。 动画做到自然需要在一开始对于整体动画有一构想，对于细节部分动画有自己的把握，并且与设计师进行沟通交流，理解动画细节与需注意要点。在完成动画后在和设计师进行交流，修正动画差异点。 如何让图片做到体积最小将动画中所涉及到的图片尽可能进行组合、拆分放入一张sprite图。这样做可以有效的减少请求数量，并且同时能对于零碎化的素材能够很好的进行管理。如图，sprite的大小为182*665，充分利用空间，对各种元素拼合，做到体积最小。 如果条件允许，使用JPEG格式的sprite图。JPEG作为一种压缩图片格式，相对于PNG的天然优势就是有着良好的压缩率，并且JPEG有着一个极其重要的特征——渐进传输（即先传输图像的轮廓，然后逐步传输数据，不断提高图像质量，让图像由朦胧到清晰显示）。在控制体积方面，有着天然优势。 对于不影响主体感官的图片进行大程度压缩。对于非主要展示小图片可以调大压缩幅度，这样就算压缩出来有瑕疵也不会被用户肉眼所注意且对整体效果无影响。 使用优良的图片压缩工具在这里推荐tinypng这一在线网站，TinyPng使用智能的有损压缩算法，（与pngquant 算法基本类似）通过减少图片的颜色，从而在几乎不影响视觉的情况下，显著的减少图片的体积。相对其他压缩网站来说，基本可以做到很小。 以下是百度到的在线图片压缩网站与其对比：可以看出，tinypng和图好快这两个网站可以将png压的非常狠，而对视觉影像效果较小，对于一些无需太过精细的图片可以使用一些优良的第三方压缩工具进行压缩。 如何做到动效还原静态设计稿的还原要做到动效的还原，首先需要做到将静态设计稿的还原。因为动画部分一般不会设计到文字变动效果，所以做到静态设计稿还原是一大必要。 动效的还原 针对一些较为复杂的动效，与设计师进行沟通，确定效果方案，索要动画数据。 针对设计师所给出的gif图，在与其沟通的基础上，做出初版动效。 根据设计师所给出的意见，对动画细节进行修改。 参考资料： CSS3动画和js动画各有什么优劣 无线性能优化Composite TinyPNG 的压缩 PNG 算法好厉害 Chrome渲染分析之Rendering工具使用]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE6/7常见问题 收集及解决（二）]]></title>
    <url>%2F2016%2F09%2F24%2Fie67problem2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前搜集和遇到的ie6/7中的问题及解决（二）。 float的div闭合;清除浮动;自适应高度; ①这里的NOTfloatC并不希望继续平移，而是希望往下排.(其中floatA、floatB的属性已经设置为 float:left;) 这段代码在IE中毫无问题，问题出在FF。原因是NOTfloatC并非float标签，必须将float标签闭合。12345&lt;#div id=”wrapper” &gt; &lt;#div id=”floatA” &gt;&lt;/div&gt; &lt;#div id=”floatB” &gt;&lt;/div&gt; &lt;#div id=” NOTfloatC” &gt;&lt;/div&gt;&lt;/div&gt; 在 &lt;#div class=”floatB”&gt; &lt;#div class=”NOTfloatC”&gt;之间加上 &lt; #div class=”clear”&gt;这个div一定要注意位置，而且必须与两个具有float属性的div同级，之间不能存在嵌套关系， 否则会产生异常。 并且将clear这种样式定义为为如下即可：1.clear&#123; clear:both;&#125; ②作为外部 wrapper 的 div 不要定死高度,为了让高度能自动适应，要在wrapper里面加上123456789101112131415161718192021 #wrapper&#123; overflow:hidden; zoom:1; &#125;``` 当包含float的 box的时候，高度自动适应在IE下无效，这时候应该触发IE的layout私有属性(万恶的IE啊！)用zoom:1;可以做到，这样就达到了兼容.③对于排版,我们用得最多的css描述可能就是float:left.有的时候我们需要在n栏的float div后面做一个统一的背景,譬如: &lt;div id=”page”&gt;&lt;div id=”left”&gt;&lt;/div&gt;&lt;div id=”center”&gt;&lt;/div&gt;&lt;div id=”right”&gt;&lt;/div&gt;&lt;/div&gt;比如我们要将page的背景设置成蓝色,以达到所有三栏的背景颜色是蓝色的目的,但是我们会发现随着left center right的向下拉长,而 page居然保存高度不变,问题来了,原因在于page不是float属性,而我们的page由于要居中,不能设置成float,所以我们应该这样解决 ```html&lt;div id=”page”&gt; &lt;div id=”bg” style=”float:left;width:100%”&gt; &lt;div id=”left”&gt;&lt;/div&gt; &lt;div id=”center”&gt;&lt;/div&gt; &lt;div id=”right”&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 再嵌入一个float left而宽度是100%的DIV解决之 ④万能float 闭合(非常重要!) 关于 clear float 的原理可参见 [How To Clear Floats Without Structural Markup],将以下代码加入Global CSS 中,给需要闭合的div加上 class=”clearfix” 即可,屡试不爽. / Clear Fix / .clearfix:after { content:”.”; display:block; height:0; clear:both; visibility:hidden; } .clearfix { display:inline-block; } / Hide from IE Mac / .clearfix {display:block;} / End hide from IE Mac / / end of clearfix / 或者这样设置：.hackbox{ display:table; //将对象作为块元素级的表格显示} 高度不适应高度不适应是当内层对象的高度发生变化时外层高度不能自动进行调节，特别是当内层对象使用margin 或paddign 时。 例：#box {background-color:#eee; } #box p {margin-top: 20px;margin-bottom: 20px; text-align:center; } p对象中的内容 解决方法：在P对象上下各加2个空的div对象CSS代码：.1{height:0px;overflow:hidden;}或者为DIV加上border属性。 IE6下为什么图片下有空隙产生解决这个BUG的方法也有很多,可以是改变html的排版,或者设置img 为display:block 或者设置vertical-align 属性为 vertical-align:top | bottom |middle |text-bottom 都可以解决. 如何对齐文本与文本输入框加上 vertical-align:middle; web标准中定义id与class有什么区别吗一.web标准中是不容许重复ID的,比如div id=”aa”不容许重复2次,而class 定义的是类,理论上可以无限重复, 这样需要多次引用的定义便可以使用他. 二.属性的优先级问题 ID 的优先级要高于class,看上面的例子 三.方便JS等客户端脚本,如果在页面中要对某个对象进行脚本操作,那么可以给他定义一个ID,否则只能利用遍历页面元素加上指定特定属性来找到它,这是相对浪费时间资源, 远远不如一个ID来得简单. LI中内容超过长度后以省略号显示的方法此方法适用与IE与OP浏览器 1234567li&#123; width:200px; white-space:nowrap; text-overflow:ellipsis; -o-text-overflow:ellipsis; overflow: hidden;&#125; 为什么web标准中IE无法设置滚动条颜色了解决办法是将body换成html &lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;123456789 html &#123; scrollbar-face-color:#f6f6f6; scrollbar-highlight-color:#fff; scrollbar-shadow-color:#eeeeee; scrollbar-3dlight-color:#eeeeee; scrollbar-arrow-color:#000; scrollbar-track-color:#fff; scrollbar-darkshadow-color:#fff;&#125; 怎么样才能让层显示在FLASH之上呢解决的办法是给FLASH设置透明 怎样使一个层垂直居中于浏览器中这里我们使用百分比绝对定位,与外补丁负值的方法,负值的大小为其自身宽度高度除以二]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>ie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE6/7常见问题 收集及解决（一）]]></title>
    <url>%2F2016%2F08%2F05%2Fie67problem1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前搜集和遇到的ie6/7中的问题及解决（一）。 IE6下，快元素有浮动，和横向的margin，横向的margin值会被放大成两倍 解决：将快元素display设置为 inline； IE6,7下几px的间隙问题在IE6，7下li本身没有浮动，但内容浮动就会多出几px间隙 解决：（1）li加上浮动 （2）给li加vertical-align加top/bottom等 //垂直对齐方式 IE6,7最小高度问题： 解决：（1）font-size:0; //清除IE6最小高度为19px，但是设置后最小高度为2Px,无法达到1px,效果不佳；(2)zoom:0.0X;效果同(1),zoom为使用对象的实际尺寸(用浮点数/百分比来定义缩放比例。不允许负值)（3）overflow:hidden； //效果完美 div的垂直居中问题 vertical-align:middle; 将行距增加到和整个DIV一样高 line-height:200px; 然后插入文字，就垂直居中了。缺点是要控制内容不要换行 margin加倍的问题 设置为float的div在ie下设置的margin会加倍。这是一个ie6都存在的bug。解决方案是在这个div里面加上display:inline; example:12345678910&lt;style&gt; #IamFloat&#123; float:left; /*IE下理解为10px*/ margin:5px; /*设置了display后，IE下再理解为5px*/ display:inline; &#125;&lt;/style&gt;&lt;#div id=”imfloat”&gt;&lt;/div&gt; 这里细说一下block与inline两个元素：block元素的特点是,总是在新行上开始,高度,宽度,行高,边距都可以控制(块元素);Inline元素的特点是,和其他元素在同一行上,不可控制(内嵌元 素); #box{ display:block; //可以为内嵌元素模拟为块元素 display:inline; //实现同一行排列的效果 diplay:table; IE与宽度和高度的问题IE 不认得min-这个定义，但实际上它把正常的width和height当作有min的情况来使。这样问题就大了，如果只用宽度和高度，正常的浏览器里这两个值就不会变， 如果只用min-width和min-height的话，IE下面根本等于没有设置宽度和高度。 比如要设置背景图片，这个宽度是比较重要的。要解决这个问题，可以这样：12345678910111213&lt;style&gt; #box&#123; width: 80px; height: 35px; &#125; html&gt;body #box&#123; width: auto; height: auto; min-width: 80px; min-height: 35px; &#125;&lt;/style&gt;&lt;#div id=”box”&gt;&lt;/div&gt; DIV浮动IE文本产生3象素的bug左边对象浮动，右边采用外补丁的左边距来定位，右边对象内的文本会离左边有3px的间距.1234567891011121314151617181920&lt;style&gt; #box&#123; float:left; width:800px; &#125; #left&#123; float:left; width:50%; &#125; #right&#123; width:50%; &#125; *html #left&#123; margin-right:-3px; //这句是关键 &#125;&lt;/style&gt;&lt;div id="box"&gt; &lt;div id="left"&gt;&lt;/div&gt; &lt;div id="right"&gt;&lt;/div&gt;&lt;/div&gt; IE捉迷藏的问题当div应用复杂的时候每个栏中又有一些链接，DIV等这个时候容易发生捉迷藏的问题。有些内容显示不出来，当鼠标选择这个区域是发现内容确实在页面。 解决办法：对#layout使用line-height属性 或者给#layout使用固定高和宽。页面结构尽量简单。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>ie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery相关基础]]></title>
    <url>%2F2016%2F02%2F15%2Fjqbase1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文是笔者初学Jq时留下的一些基础。 1. 操作属性123456789101112131415161718192021222324attr: $('xxx').attr('属性') //一个参数是获取属性 $('xxx').attr('属性','xxx') //两个参数是设置属性filter: $('XXX').filter('xx') //筛选，过滤 $('XXX').filter('[title=XX]')not: $('XXX').not('xx') //filter反义词，不包含XX属性的元素has: $('XXX').has('xx') //XXX里面的元素内部是否包含XX元素,如果包含，则该元素包含在结果中。如果不包含，那么就排除。 &lt;div id='xxx'&gt;&lt;span id='xx'&gt;&lt;/span&gt;&lt;/div&gt;find: //find()方法是获得在当前结果集中每个元素的后代。满足过滤条件的则保留，保留的是后代. //与has（）不同，而has()方法中，参数只做为条件，符合条件的，它的前元素加入新的结果集，而不是后代加入新的结果集。next: //下一个兄弟节点prev: //上一个兄弟节点index: $('XXX').index() //在当前元素所在所有兄弟节点中的位置；addClass: $('XXX').addClass('XX xx'); //添加class XX,xx;removeClass: $('XXX').removeClass('XX'); //移除class;width/height: $('XXX').width() //widthinnerWidth/innerHeight: $('XXX').innerWidth() //width+paddingouterWidth/outerHeight: $('XXX').outerWidth() //width+padding+borderouterWidth/outerHeight: $('XXX').outerWidth(true)//width+padding+border+margin 2. DOM操作1234567891011121314151617181920212223242526272829303132insertBefore: $('b').insetBefor($('a')); //将b剪切到a前面inserAfter: $('b').insetBefor($('a')); //将b剪切到a后面appendTo: $('Fuji').appendTo($('Ziji')); //在Fuji中 末尾 插入Ziji;prependTo: $('Fuji').prependTo($('Ziji')); //在Fuji中 开始 插入Ziji;before,after,append,prepend: $('b').befor($('a')); //b的前面是a = 将a剪切到b前面；其他同理；remove： $('a').remove(); //移除a；scrollTop/scrollLeft: 纵向/横向滚动条距离 offset(): offset().left; //元素距屏幕左边的距离，无视父级；Top同理；position: position().left; //到有定位的父级的left值，把当前元素转化为类似定位的形式；offsetParent(): //获取有定位的父级parent: //获取父级parents: $('a').parents('XXX') //获取祖先节点，传入参数可筛选closest: //获取最近的指定的祖先节点（包括当前元素自身）必须传入参数，只能找到一个元素siblings: //获取兄弟节点,添加参数可筛选；nextAll/preAll: //下面/上面所有兄弟节点，添加参数可筛选；parentsUntil/nextUntil/preUntil: //截至到(参数)的筛选；clone: $('a').clone().appendTo.... //克隆，如果clone中传入true，则会克隆其方法；wrap: $('a').wrap('&lt;div&gt;') //在a外面包装一个div;wrapAll:$('a').wrapAll('&lt;div&gt;') //在所有的a外面都包装一个div；会改变DOM节点方式，注意wrapInner: $('a').wrapInner('&lt;div&gt;') //在所有a内部都包装一个div；unwrap: $('a').unwrap() //方法删除被选元素的父元素add: var a=$('a').add('b'); //a同时包含了a,b;slice: //分割serialize/serializeArray 3. event1234567891011121314151617181920212223242526272829303132333435ev.pageX: 鼠标坐标 //相对于文档 clientX:相对于可视区ev.which：键值 //包括鼠标键值ev,preventDefault: //阻止默认事件ev.stopPropagation: //阻止冒泡操作return false: //既阻止默认事件，又阻止冒泡操作delegate: $('ul').delegate('li','click',function()&#123; &#125;) //利用冒泡原理对Li添加事件；名称：事件委托 //优点：省去循环操作，对于后添加进来的元素同样成立，性能优；undelegate: //阻止事件委托；trigger: $('a').on('XXX',fn1); $('a').trigger('XXX') //主动触发XXX事件；on: $('a').on('event',fn); $('a').on(&#123;'event':fn1,'event2':fn2&#125;); $('a').on('event',&#123;"XX":xx&#125;,fn(ev)&#123; ev.date.XX //data为json格式； ev.target //事件源，操作的是谁 ev.type //事件类型 &#125;);off: 取消事件bind(type,[data],fn) 为每个匹配元素的特定事件绑定事件处理函数$("a").bind("click",function()&#123;alert("ok");&#125;);live(type,[data],fn) 给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的$("a").live("click",function()&#123;alert("ok");&#125;);delegate(selector,[type],[data],fn) 指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数$("#container").delegate("a","click",function()&#123;alert("ok");&#125;)on(events,[selector],[data],fn) 在选择元素上绑定一个或多个事件的事件处理函数差别：.bind()是直接绑定在元素上.live()则是通过冒泡的方式来绑定到元素上的。更适合列表类型的，绑定到document DOM节点上。和.bind()的优势是支持动态数据。.delegate()则是更精确的小范围使用事件代理，性能优于.live().on()则是最新的1.9版本整合了之前的三种方式的新事件绑定机制 4. 其他1234567891011one:$('a').one('event',fn); //只触发一次事件val: $('a').val; $('a').val(xxx); //获取value值,更改value值size: //获取长度；each: $('a').each(function(i,elem)&#123;&#125;) //for in; 参数1：下表；参数2：每个元素hover: //鼠标移入移出hide/show: $('a').hide(time); //隐藏/显示；加了时间(time)会有动画；fadeIn/fadeOut: $('a').fadeIn(time) //淡入淡出；默认400毫秒； 参数2：透明度slideDown/slideUp: $('a').slideDown(time) //向上卷曲/向下展开 5. 基础扩充12345678get: $('a').get(0).innerHTML; //使jq和js可以混合使用，get需要指定集合第几个使用； for(var i=0;i&lt;$('a').get().length;i++)&#123; &#125; for(var i=0;i&lt;$('a').length;i++)&#123; &#125; //源码中也有Length属性outerWidth: //可以获取到隐藏元素的宽高，原生offsetWidth无法获取隐藏元素宽高text: //只获取文本内容，不会获取到标签detach: //跟remove方法一样，不过会保留删除这个元素被删除前的操作行为 6. 动画123456789101112animate: //参数1：运动的值和属性 //参数2：运动的时间 //参数3：运动形式：swing(慢快慢)，linear(匀速) //参数4：回调函数stop: //阻止当前运动， //参数1：true，阻止所有运动； //参数2：true,立即让当前动画直接走完；finish: //立即停止到所有指定的目标点；delay: //延迟； 7. 工具方法12345678910$.type: js:typeof; //相比于typeof ，功能更强大，能判断更多的类型；$.trim: js:无trim$.inArray: var a=['a','b','c','d']; $.inArray('b',a); //类似于indexOf$.proxy: $.proxy(fn1,xxxx) //改变this指向；将fn1中this的指向xxxx; $.proxy(fn1,xxxx)(a,b) //传参a,b;会立即执行； $.proxy(fn1,xxxx,a,b) //传参a.b;调用才执行；$.noConflict: var xxx=$.noConflict(); //xxx可以当作$使用；例如：xxx('a').css....;$.parseJSON; //转为json;$.makeArray: //类数组转为真正数组； 8. ajax1234567$.ajax(&#123; url:xxxx, data:xxxxxx, type:'POST/GET', success:function()&#123; &#125;, error:function()&#123; &#125;,.........&#125;) 9. 扩展1234567$.extend: 扩展工具方法下的插件形式 $.xxx() $.yyy(); $.extend(&#123; leftTrim:function(str)&#123; return str.replace(/^\s+/,''); &#125; &#125;);$.fn.extend: 扩展JQ对象下的插件形式 $().xxx() $().yyy();]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php数据库操作]]></title>
    <url>%2F2015%2F08%2F24%2Fphpsql%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;此为毕业时写Php链接数据库时的“遗迹”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * Created by PhpStorm. * User: yuyud * Date: 2016/1/11 0011 * Time: 16:43 *//** * 数据库连接 * Class Mysql */class Mysql&#123; private $mysql_server_name='localhost'; private $mysql_username='root'; private $mysql_password=''; private $mysql_database='webmap'; private $mysql_charset='utf8'; private $mysqli; function __construct()&#123; $this-&gt;connect(); &#125; function __destruct()&#123; $this-&gt;close();// echo '数据成功关闭'; &#125; /** * sql连接 */ function connect()&#123; $this-&gt;mysqli=new mysqli($this-&gt;mysql_server_name,$this-&gt;mysql_username, $this-&gt;mysql_password,$this-&gt;mysql_database); //检查连接是否成功 if (mysqli_connect_errno())&#123; //注意mysqli_connect_error()新特性 die('Unable to connect!'. mysqli_connect_errno().":".mysqli_connect_error()); &#125; if (!$this-&gt;mysqli-&gt;set_charset($this-&gt;mysql_charset)) &#123; printf("Error loading character set utf8: %s\n", $this-&gt;mysqli-&gt;error); &#125; else &#123; $this-&gt;mysqli-&gt;character_set_name(); &#125;// echo "成功！";// return $this-&gt;mysqli; &#125;function insert($table,$array)&#123; $keys=join(",",array_keys($array)); $vals="'".join("','",array_values($array))."'"; $sql="insert $table ($keys) values(&#123;$vals&#125;)"; mysqli_query($this-&gt;mysqli, $sql); return mysqli_insert_id($this-&gt;mysqli);&#125;function update($table,$array,$where=null)&#123; $str=''; foreach($array as $key=&gt;$val)&#123; if($str==null)&#123; $sep=""; &#125;else&#123; $sep=","; &#125; $str.=$sep.$key."='".$val."'"; &#125; $sql="update $table set $str".($where==null?null:" where ".$where); $result=mysqli_query($this-&gt;mysqli,$sql); //var_dump($result); //var_dump(mysql_affected_rows());exit; if($result)&#123; return mysqli_affected_rows($this-&gt;mysqli); &#125;else&#123; return false; &#125;&#125;function delete($table,$where=null)&#123; $where=$where==null?null:" where ".$where; $sql="delete from $table $where"; mysqli_query($this-&gt;mysqli,$sql); return mysqli_affected_rows($this-&gt;mysqli);&#125;function fetchOne($sql,$result_type=MYSQLI_ASSOC)&#123; $result=mysqli_query($this-&gt;mysqli,$sql); $row=mysqli_fetch_array($result,$result_type); return $row;&#125;function fetchAll($sql,$result_type=MYSQLI_ASSOC)&#123; $result=mysqli_query($this-&gt;mysqli,$sql); $rows=[]; while(@$row=mysqli_fetch_array($result,$result_type))&#123; $rows[]=$row; &#125; return $rows;&#125;function getResultNum($sql)&#123; $result=mysqli_query($this-&gt;mysqli,$sql); return mysqli_num_rows($result); &#125; function getInsertId()&#123; return mysqli_insert_id($this-&gt;mysqli); &#125; function close()&#123; mysqli_close($this-&gt;mysqli); &#125;&#125;/** * 此class一些操作 *///数据库操作示例//$test=new Mysql();//$res=$test-&gt;insert("admins",['admins_name'=&gt;'ccc','admins_pass'=&gt;md5('ccc')]);//$res=$test-&gt;update("admins",['admins_name'=&gt;'king','admins_pass'=&gt;md5('king')],"admins_id=2");//$res = $test-&gt;delete("admins", "admins_name='ccc'");/*$res=$test-&gt;fetchAll("select * from admins");var_dump($res);echo count($res);*///echo $test-&gt;getResultNum("select * from admins where admins_name='ccc'");]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>sql</tag>
      </tags>
  </entry>
</search>
